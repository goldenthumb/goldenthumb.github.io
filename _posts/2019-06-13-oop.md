---
layout: post
title: '객체 지향 프로그래밍'
tags: [oop, 객체지향프로그래밍]
---

먼저, 좋은 프로그래머가 되려면 '돌아가기만 하면 되지'라는 마인드를 가지면 안된다고 생각합니다. 
타인과의 커뮤니케이션을 중시하고 코드의 과도한 복잡성을 피하면서도 유연성 있는 코드를 작성해야 합니다. 
그 이유는 경제성 때문입니다. 소프트웨어 비용은 개발 비용 + 유지 비용입니다. 
유지 비용은 이해 비용 + 수정 비용 + 테스트 비용 + 설치 비용이 들기 때문에 우리는 유지비용에 신경쓸 필요가 있습니다.

켄트벡의 구현패턴을 읽고 가장 뜨금 했던 문구는 '본능에 의해 코딩하는 것을 멈추라' 라는 말이였습니다. 
유지 비용을 줄이기 위해서는 일단 코드 양이 적어야합니다. 그리고 그 코드로 개발자 간의 커뮤니케이션이 가능해야 하고 단순하면서도 유연성이 좋아야합니다.
그러기 위해서는 몇가지 원칙이 필요하게 되는데 이 책에서는 아래와 같은 원칙을 알려줍니다.

+ 지역적 변화와 최소 중복의 원칙
    * 코드를 수정할 때 함께 바꿔야 하는 부분을 최소화해야 한다.
    * 짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지로 나누는 작업 
+ 로직과 데이터의 결합
    * 로직과 데이터를 모두 수정해야할 경우가 많으므로, 데이터와 그 데이터를 처리하는 로직을 밀접하게 배치 한다.
+ 대칭성
    * 하나의 아이디어를 프로그램 전체에서 일관된 방식으로 표현하는 통일성이 있어야 한다.    
+ 선언적 표현 
    * 복잡한 로직이 없다면 수행되는 로직을 선언적 표현을 사용해야 한다. 선언적으로 표현을 잘 하면 예외적인 경우를 생각할 시간을 줄여줍니다.
+ 변화율 
    * 변하는 로직과 데이터를 함께 관리하고 변화율이 다른 로직과 데이터는 분리해야 한다.

이 책을 읽어 나가면서 가장 떠올랐던 부분은 객체지향프로그래밍과 디자인 패턴 그리고 함수형 프로그래밍과 같은 설계 방법론들이 생각 났습니다. 우리는 위와 같은 목적을 가지고 프로그램 설계 방법론들을 정의하고 개발을 해왔던 것이라고 생각했습니다. 
그래서 저는 먼저 객체 지향 프로그래밍이 무엇인지 알아보기로 하였습니다. 

## 객체 지향 프로그래밍이란 무엇인가?
---
> 객체가 맡은 역할을 수행하기 위한 목적을 가지고 캡슐화, 다형성, 상속 을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것입니다.

객체 지향 프로그래밍(OOP)는 실세계를 모델링 하기 위해 추상화를 사용하는 프로그래밍 패러다임입니다. 더 나은 도메인 분석과 시스템 디자인의 통합을 제공 함으로써 실세계 모델링을 더 잘 지원합니다.
객체를 사용해서 효과적인 프로그래밍을 하기 위해서는 로직을 클래스 단위로 어떻게 구성해야 하는지, 로직 사이의 차이점을 어떻게 효과적으로 표현해야 하는지를 배워야 합니다.
객체지향의 세계는 협력하는 자율적인 객체들의 공동체이므로 실세계의 사물을 추상화(Abstraction) 하고, 캡슐화(Encapsulation) 하며, 계층구조는 상속(Inheritance)시키며, 부모와 다른 자식의 특성, 행위는 다형성(Polymorphism) 으로 구현해야 합니다.


### 함수형 프로그래밍과의 차이
상태를 어떤 식으로 다루는지의 차이점이 객체지향과 함수형의 큰 차이점입니다.
객체지향은 상태와 상태를 다루는 처리를 명시적으로 하고 있습니다. 프로그래밍을 하면서 '상태'에 이름을 붙이고, 범위를 관리하고, 필요 이상으로 의존되지 않도록 제약을 거는 것으로 하나의 부품, 가상 기계로 처리할 수 있도록 하여 문제를 해결합니다.
반면에 함수형은 프로그램에서 변수 간의 관계성이 선언적으로 기술되어 불변성(immutability)이 유지되게 합니다. 함수형 스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성합니다. 일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태를 사용하는 객체지향 스타일이 낫다고 생각합니다. 
동시성-분산-비동기가 주목을 받고 있는 지금, 다시 함수형에 관심이 모여지고 있지만 객체지향에서도 어느 정도까지는 추상화하여도 명시적 상태를 다루기 쉽기 때문에 적절히 조율해서 사용하는게 낫다고 생각합니다.


### 용어 정리
+ 클래스
    * 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것비슷한 성질을 가진 것
    * 비슷한 성질을 가진 것
+ 인스턴스(객체)
    * 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터
    * 클래스가 구체화된 것
+ 캡슐화의 목적
    * 코드를 재수정 없이 재활용하는 것
    * 프로그램 코드에서 변수와 함수를 재활용하기에는 분산되어 있기 때문에 재활용이 어려웠으나 캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활해짐.
+ 다형성
    * 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것 
    * 오버라이딩(Overriding), 오버로딩(Overloading)
+ 오버라이딩
    * 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것
+ 오버로딩
    * 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것
+ 구현 은닉
    * 객체의 인터페이스와만 상호작용함으로써 내부 구현은 바깥 세상으로 부터 감춤
+ 도메인
    * 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발 됨.
+ 타입(type)
    * 특정 인터페이스를 나타낼 때 사용하는 이름
+ 인터페이스
    * 구현이 빠진 여러 연산의 집합
+ 클래스와 타입 차이점
    * 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의하고 클래스는 객체의 내부 상태와 그 객체의 연산에 대한 구현 방법을 정의
    * 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의
    * 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있음
    * 객체의 구현은 다를지라도 인터페이스는 같을 수 있음
+ Mixin 패턴
    * Mixin 패턴은 상속이 아닌 포함의 구조를 가짐
    * 즉, 공통 모듈을 가진 부모 객체를 상속하여 메시지를 교환하는 방식이 아니라 필요한 부분만 포함하여 사용
    * Mixin 패턴의 장점은 복잡한 상속 구조의 애매함을 피할 수 있으며 행위를 분리함으로써 명확하고 다양한 인터페이스를 사용할 수 있음
+ 은닉화
    * 클래스의 속성들을 private 으로 만들어 클래스 밖에서 함부로 건드리지 못하게 하는 것
+ 추상화
    * 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것
    * 형상을 뽑아내어 변화시키는 것 (일반화)
+ 객체지향에서 추상화
    * 공통의 속성이나 기능을 묶어 이름을 붙이는 것 (클래스를 정의하는 것)
